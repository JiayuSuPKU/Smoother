Module smoother.losses
======================
Transform spatial covariance into spatial loss

Functions
---------

    
`kl_loss(p, weights=None)`
:   Calculate kl divergence using pytorch.
    
    Args:
            p (2D array): Probability distributions, num_group x num_spot.
                    Each column is one discrete distribution over num_group groups.
            weights (2D array): Spatial weight matrix, num_spot x num_spot.
                    If not None, will scale pairwise KL divergence by the weight matrix.
    
    Returns:
            kl (float): The mean pairwise KL divergence between spots, num_spot x num_spot.

    
`kl_loss_scipy(p, weights=None)`
:   Calculate KL divergence using scipy.
    
    Args:
            p (2D array): Probability distributions, num_group x num_spot.
                    Each column is one discrete distribution over num_group groups.
            weights (2D array): Spatial weight matrix, num_spot x num_spot.
                    If not None, will scale pairwise KL divergence by the weight matrix.
    
    Returns:
            kl (float): The mean pairwise KL divergence between spots, num_spot x num_spot.

    
`quadratic_loss(beta, inv_cov, group_scales, normalize=True)`
:   Calculate quadratic smoothing loss using torch.
    
    This is the main loss that transforms spatial covariance into spatial loss. It is equivalent to
    adding a multivariate normal prior with precision matrix `inv_cov` on `beta` in a regression
    setting. See model description for more details.
    
    Args:
            beta (2D tensor): Columns of regression coefficients, num_group x num_spot.
            inv_cov (3D tensor): Inverse covariance (precision) matrix of spatial variables of each group,
                    (num_group or 1) x n x n. If the first dimension has length 1, all groups will have the
                    same covariance structure.
            group_scales (1D tensor or float): Relative prior confidence of each group. The higher the
                    confidence, the stronger the smoothing will be. If float, all groups will have
                    the same confidence.
            normalize (bool): If True, normalize the likelihood over the size of beta for comparability.
    
    Returns:
            neg_loglik (float): Sum of quadratic loss, i.e., the negative likelihood of the corresponding
                    multivariate normal prior on `beta`.

    
`sparse_quadratic_loss(beta, inv_cov_2d_sp, group_scales, normalize=True)`
:   Calculate quadratic smoothing loss using torch.sparse.
    
    This function uses the sparsity of the inverse covariance matrix to speed up the calculation.
    
    Args:
            beta (2D tensor): Columns of regression coefficients, num_group x num_spot.
            inv_cov_2d_sp (2D sparse tensor): Sparse block diagonal inverse covariance (precision) matrix
                    of each group. There are in total (num_group or 1) num_spot x num_spot blocks.
                    If 1, all groups will have the same covariance structure.
            group_scales (1D tensor or float): Relative prior confidence of each group. The higher the
                    confidence, the stronger the smoothing will be. If float, all groups will have
                    the same confidence.
            normalize (bool): If True, normalize the likelihood over the size of beta for comparability.
    
    Returns:
            neg_loglik (float): Sum of quadratic loss, i.e., the negative likelihood of the corresponding
                    multivariate normal prior on `beta`.

Classes
-------

`ContrastiveSpatialLoss(prior='icar', spatial_weights: List[smoother.weights.SpatialWeightMatrix] = None, scale_weights=1, use_sparse=True, standardize_cov=True, num_perm=10, neg2pos_ratio=0.5, lower_bound=-1, check_positive_definite=False)`
:   Spatial loss for contrastive learning.
    
    The spatial loss that maximizes similarity of a spatial random variable (num_group x num_spot)
    over true neighbors while minimizing similarity over randomly generated neighbors. See
    Zhu, Hao, Ke Sun, and Peter Koniusz. "Contrastive laplacian eigenmaps."
     Advances in Neural Information Processing Systems 34 (2021).
    https://arxiv.org/abs/2201.05493
    
    By default, the inverse covariance matrix generated from `prior = 'icar'` and
     `scale_weights = 1` is the graph laplacian. Set `standardize_cov = True` to normalize
    the graph laplacian.
    
    Attributes: See `SpatialLoss`.
            num_perm (int): Number of negative graphs (generated by randomly shuffling spots).
            neg2pos_ratio (float): Relative importance of negative samples to positive samples.
            lower_bound (float): Lower bound of the loss in case that cov is not positive semi-definite.
            check_neg_samples (bool): Whether to check if resulting cov is positive definite.
    
    Initializes internal Module state, shared by both nn.Module and ScriptModule.

    ### Ancestors (in MRO)

    * smoother.losses.SpatialLoss
    * torch.nn.modules.module.Module

    ### Methods

    `check_positive_definite(self, n_tests=10)`
    :   Check if the covariance matrix is positive semi-definite.

    `forward(self, coefs) ‑> Callable[..., Any]`
    :   Calculate contrastive spatial loss.

`SpatialLoss(prior, spatial_weights: List[smoother.weights.SpatialWeightMatrix] = None, scale_weights=1, use_sparse=True, standardize_cov=False)`
:   Spatial loss.
    
    The spatial smoothing loss on a spatial random variable (num_group x num_spot).
    
    Attributes:
            prior (str): The prior spatial process model, can be one of 'sma','sar', 'car', 'icar'.
            spatial_weights (List[SpatialWeightMatrix]): Spatial weight matrix collection of
                    length num_group or 1. If 1 then all groups will be subject to the same covariance.
            scale_weights (float): Smoothing effect size (i.e., `l` in SpatialWeightMatrix.get_inv_cov).
            use_sparse (bool): Whether to use sparse inverse covariance matrix in the calculation.
            standardize_cov (bool): Whether to standardize the covariance matrix to have same variance (1)
                      across locations. Only proper covariance can be standardized.
            inv_cov (3D tensor): Inverse covariance (precision) matrix of spatial variables of each group,
                    (num_group or 1) x n x n. If the first dimension has length 1, all groups will have the
                    same covariance structure.
            inv_cov_2d_sp (2D sparse tensor): Sparse block diagonal inverse covariance (precision) matrix.
            confidences (1D tensor or float): Relative prior confidence of each group. The higher the
                    confidence, the stronger the smoothing will be. If float, all groups will have
                    the same confidence.
    
    Initializes internal Module state, shared by both nn.Module and ScriptModule.

    ### Ancestors (in MRO)

    * torch.nn.modules.module.Module

    ### Descendants

    * smoother.losses.ContrastiveSpatialLoss

    ### Methods

    `calc_cov_decay(self, coords, max_k=50, step_k=1, topk=False, cov_id=0, quantiles=[0.1, 0.25, 0.5, 0.75, 0.9])`
    :   Calculate spatial covariance decay over distance.
        
        Covariance measured between k-nearest neighbors. If the number of covariance
        matrices (i.e. self.inv_cov.shape[0]) is larger than 1, use 'cov_id' to select
        the covariance matrix to use.
        
        Args:
                coords (2D tensor): Coordinates of spots, num_spot x 2.
                max_k: Maximum number of k in k-nearest neighbors to extract covariance.
                step_k: Step size of k.
                topk: Whether to use top-k neighbors. If True, for each k, the covariance
                        distribution represents all j-th nearest neighbors where j <= k.
                cov_id (int): Index of the covariance matrix to use.
                quantiles: Quantiles of covariance distribution to report.
        
        Returns:
                corr_decay_quantiles_df (pd.DataFrame): Correlation decay quantiles.
                var_quantiles_df (pd.DataFrame): Per-spot variance quantiles.

    `estimate_confidence(self, ref_exp, st_exp, method='lr') ‑> None`
    :   Estimate the relative confidence for each group.
        
        The covariance matrix will be scaled accordingly.
        
        Args:
                ref_exp (2D tensor): Bulk expression signiture matrix, num_gene x num_group.
                st_exp (2D tensor): Spatial expression matrix, num_gene x num_spot.
                method (str): Method used to estimate variance.

    `forward(self, coefs) ‑> Callable[..., Any]`
    :   Calculate spatial loss.
        
        Args:
                coefs (2D tensor): Columns of regression coefficients, num_group x num_spot.

`TopLoss(betti_priors: dict, coords_xy)`
:   Topological loss.
    
    The topological smoothing loss on a spatial random variable (num_group x num_spot).
    
    Attributes:
            betti_prior (dict): A nested dictionary that specifies topological priors for each group.
                    {group_id: {betti_k : expectation}}.
            coords_xy (2D array): Spatial coordinates (2D), num_spot x 2.
            pdfn (topologylayer.nn.LevelSetLayer2D): Super-level set layer.
            topfn (dict): Topological features for each group.
                    {group_id: {betti_k: topologylayer.nn.PartialSumBarcodeLengths}}.
    
    Initializes internal Module state, shared by both nn.Module and ScriptModule.

    ### Ancestors (in MRO)

    * torch.nn.modules.module.Module

    ### Methods

    `forward(self, coefs) ‑> Callable[..., Any]`
    :   Calculate topological loss.
        
        Args:
                coefs (2D tensor): Columns of regression coefficients, num_group x num_spot.

    `reshape_coefs(self, beta, pad_value: float = None)`
    :   Reshape 2D coefficients into 3D and pad with zeros.
        
        The original coefficient matrix has 1 location axis (the first dimension)
        while the transformed matrix will have 2 location axes (x and y, the first two).
        Spatial arrangement specified in `self.coords_xy`.
        
        Args:
                beta (2D array): Columns of regression coefficients, num_group x num_spot.
                pad_value (float): Value of coefficients at unobserved regions.